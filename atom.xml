<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jev001&#39;s Blog</title>
  
  
  <link href="http://jev001.github.io/atom.xml" rel="self"/>
  
  <link href="http://jev001.github.io/"/>
  <updated>2023-02-08T07:14:52.112Z</updated>
  <id>http://jev001.github.io/</id>
  
  <author>
    <name>jev001</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux备份还原修复UEFI引导</title>
    <link href="http://jev001.github.io/2023/02/08/linux%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E4%BF%AE%E5%A4%8DUEFI%E5%BC%95%E5%AF%BC/"/>
    <id>http://jev001.github.io/2023/02/08/linux%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%E4%BF%AE%E5%A4%8DUEFI%E5%BC%95%E5%AF%BC/</id>
    <published>2023-02-08T06:42:53.000Z</published>
    <updated>2023-02-08T07:14:52.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="强行备份还原-魔术方式"><a href="#强行备份还原-魔术方式" class="headerlink" title="强行备份还原(魔术方式)"></a>强行备份还原(魔术方式)</h2><ul><li>该方式常用于本机电脑下备份系统后, 需要还原引导,其中因为安装时目录使用是按照uefi方式安装的,所以只需要添加UEFI进行驱动即可</li></ul><ol><li>使用<code>blkid</code>查看当前分区下的uuid<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">blkid</span><br><span class="line"><span class="comment">#/dev/sda2: UUID=&quot;6d30aecc-c90b-4757-bad8-e7bcb37ba881&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;4b5f9e8b-19b2-4b43-b684-ca04b0a40925&quot;</span></span><br><span class="line"><span class="comment">#/dev/sda3: UUID=&quot;efa59adb-a43d-4e4c-a166-b9ad3658489d&quot; BLOCK_SIZE=&quot;4096&quot; TYPE=&quot;ext4&quot; PARTUUID=&quot;0e519d50-cde9-493f-bda4-3e5e59793076&quot;</span></span><br><span class="line"><span class="comment">#/dev/sda1: UUID=&quot;3647-E782&quot; BLOCK_SIZE=&quot;512&quot; TYPE=&quot;vfat&quot; PARTUUID=&quot;905e3313-c764-4584-a4ad-a06c7653831b&quot;</span></span><br></pre></td></tr></table></figure></li><li>修改引导分区中的<code>grup.cfg文件</code>,该文件是<code>grubx64.efi</code>所使用,语法参考grub:[<a href="https://www.gnu.org/software/grub/manual/grub/html_node/index.html]">https://www.gnu.org/software/grub/manual/grub/html_node/index.html]</a></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 从第0快硬盘中(hd0,gpt2) 搜索分区uuid为`6d30aecc-c90b-4757-bad8-e7bcb37ba881`的分区. 搜索该分区后, 将该分区信息分配到root变量中</span><br><span class="line"># 其中该分区应该为 安装系统的根目录`/`,比如作者安装ubuntu时区分了 `/`和`/home`挂载点为两个分区</span><br><span class="line">search.fs_uuid 6d30aecc-c90b-4757-bad8-e7bcb37ba881 root hd0,gpt2 </span><br><span class="line"># prefix表示grub引导目录, 存放`grubx64.efi`的为UEFI引导目录. 此处是兼容操作,由UEFI引导启动GRUB,再由GRUB引导启动linux系统</span><br><span class="line">set prefix=($root)&#x27;/boot/grub&#x27;</span><br><span class="line"># 按照系统目录中的grub.cfg进行引导内核</span><br><span class="line">configfile $prefix/grub.cfg</span><br></pre></td></tr></table></figure><ol start="3"><li>指定ESP分区中<code>EFI/ubuntu/shimx64.efi</code>文件为引导UEFI引导项</li></ol><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>资源: ..&#x2F;linux备份还原修复UEFI引导&#x2F;EFI.tar.gz</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/436456032">https://zhuanlan.zhihu.com/p/436456032</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;强行备份还原-魔术方式&quot;&gt;&lt;a href=&quot;#强行备份还原-魔术方式&quot; class=&quot;headerlink&quot; title=&quot;强行备份还原(魔术方式)&quot;&gt;&lt;/a&gt;强行备份还原(魔术方式)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;该方式常用于本机电脑下备份系统后, 需要还原引导,其</summary>
      
    
    
    
    <category term="运维" scheme="http://jev001.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="linux" scheme="http://jev001.github.io/tags/linux/"/>
    
    <category term="UEFI" scheme="http://jev001.github.io/tags/UEFI/"/>
    
  </entry>
  
  <entry>
    <title>编译neo4j</title>
    <link href="http://jev001.github.io/2022/10/09/%E6%9D%82/%E7%BC%96%E8%AF%91neo4j/"/>
    <id>http://jev001.github.io/2022/10/09/%E6%9D%82/%E7%BC%96%E8%AF%91neo4j/</id>
    <published>2022-10-09T23:40:39.000Z</published>
    <updated>2023-02-08T07:14:52.352Z</updated>
    
    <content type="html"><![CDATA[<p>编译neo4j</p><p>注释掉 checkStyle的插件,避免被检测到当前环境的语法不支持</p><p>增加mvn打包参数</p><p><code>-Doverwrite</code>因为publicApi已经存在,使用该参数对于生成的api信息可以达到覆盖的作用</p><p><code>-DskipTests=true</code> 跳过测试用例的过程</p><p>在编译 neo4j-cypher-javacc-parser 包时, 会出现异常现象。<br>提示错误<code>illegal escape character</code>,目前解决的方式是暴力删除该文件</p><p>头发是柔软的, 也是坚硬</p><p>-server –home-dir&#x3D;&#x2F;Users&#x2F;jonah&#x2F;Downloads&#x2F;target&#x2F;neo4j-community-4.4.11-SNAPSHOT –config-dir&#x3D;&#x2F;Users&#x2F;jonah&#x2F;Downloads&#x2F;target&#x2F;neo4j-community-4.4.11-SNAPSHOT&#x2F;conf</p><p> Neo.ClientError.Security.Unauthorized: Unsupported authentication token, missing key <code>principal</code></p><p> 安装完Neo4j后 默认的初始用户名是:neo4j ，密码也是：neo4j</p><p> 填充完成密码后, 将会提示修改密码<br> express-wolf-rider-garbo-pizza-1164</p><p> org.neo4j.server.NeoBootstrapper#start<br>org.neo4j.server.NeoBootstrapper#createNeo<br>org.neo4j.graphdb.facade.DatabaseManagementServiceFactory#build<br>org.neo4j.graphdb.facade.DatabaseManagementServiceFactory#createBoltServer<br>org.neo4j.bolt.BoltServer#BoltServer<br>org.neo4j.bolt.BoltServer#init<br>网络协议初始化<br>org.neo4j.bolt.BoltServer#createExternalProtocolInitializer<br>org.neo4j.bolt.BoltServer#createLoopbackProtocolInitializer 内网<br>数据库管理服务初始化<br>org.neo4j.bolt.dbapi.BoltGraphDatabaseManagementServiceSPI 重要对外暴露 图数据库存储引擎api<br>org.neo4j.kernel.internal.GraphDatabaseAPI 图存储api</p><p>ddd模式, 完美的oop面向对象的写法. 一个node需要和另一个node创建关系<br>org.neo4j.graphdb.Node#createRelationshipTo<br>org.neo4j.kernel.impl.core.NodeEntity#createRelationshipTo</p><p>org.neo4j.server.CommunityEntryPoint 启动</p><p>dataId: neo4j-default</p><p>链接测试环境的 neo4j服务<br>[{<br>    “url”: “bolt:&#x2F;&#x2F;172.31.0.25:7687”,<br>    “username”: “neo4j”,<br>    “password”: “almond-alamo-truck-cable-prefix-5562”,<br>    “group”: “neo4j”,<br>        “enablemq”:true<br>}]</p><p><a href="http://gitlab.yunjiglobal.com/framework/yunji-community-relations.git">http://gitlab.yunjiglobal.com/framework/yunji-community-relations.git</a><br>主要代码 CommunityRelationsNeo4jService 类<br><a href="http://172.31.0.49:7474/browser/">http://172.31.0.49:7474/browser/</a> 线下测试正式库，<br><a href="http://172.31.0.49:7474/browser/">http://172.31.0.49:7474/browser/</a> 7474等同于7687</p><p>#spring.neo4j.authentication.username&#x3D;neo4j<br>#spring.neo4j.authentication.password&#x3D;almond-alamo-truck-cable-prefix-5562</p><p><a href="http://172.31.0.25:7687/browser/">http://172.31.0.25:7687/browser/</a> 环境未知</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编译neo4j&lt;/p&gt;
&lt;p&gt;注释掉 checkStyle的插件,避免被检测到当前环境的语法不支持&lt;/p&gt;
&lt;p&gt;增加mvn打包参数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-Doverwrite&lt;/code&gt;因为publicApi已经存在,使用该参数对于生成的api信息可以达到覆盖的作</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>spring三级缓存case</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98case/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98case/</id>
    <published>2022-10-09T23:36:59.000Z</published>
    <updated>2023-02-08T07:14:52.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring三级缓存case"><a href="#spring三级缓存case" class="headerlink" title="spring三级缓存case"></a>spring三级缓存case</h2><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1><p>一级缓存可以满足非增强bean的流程<br>case1: A-&gt;B,B-&gt;A 原始bean在一级缓存可以完整依赖,<br>预期: 一级缓存中存在<br>    普通A,持有普通B<br>    普通B,持有普通A<br>实际: 一级缓存中存在<br>    普通A,持有普通B<br>    普通B,持有普通A<br>结果: 符合预期</p><p>PS:一级缓存的添加点有两处,<br>   第一处: 在创建过程中添加一次, 这次是为了解决循环依赖中因为相互依赖所引起的递归死循环问题<br>   第二处: 在创建完成后, 添加到一级缓存中-&gt;此处仅仅是为了冗余或者是以往的逻辑都是在第二处中就创建</p><p>case2: A-&gt;B,B-&gt;A A和B都进行了AOP(beanPostProccor)过程.<br>预期: 一级缓存中存在<br>    增强A,持有增强B<br>    增强B,持有增强A<br>实际: 一级缓存中存在<br>    增强A,持有增强B<br>    增强B,持有普通A<br>结果: 不符合预期,原因在下方标注<br>原因: A-&gt;B-&gt;A 的过程中,<br>        1. 获取到了普通A给到普通B<br>     A-&gt;B 普通B获取到普通A后进行后置处理器,变为了增强B 此时还没有添加到一级缓存中<br>     A-&gt;B 在执行所有完成后,将增强B添加到单例池中, 此时单例池存在 [增强B,持有普通A],[普通A,没有持有任务]<br>     A    普通A获取到增强B后进行后置处理器,变为了增强A 此时还没有添加到一级缓存中<br>     A    在执行所有完成后,将增强B添加到单例池中, 此时单例池存在 [增强B,持有普通A],[普通A,增强B]</p><p>解决方式有:  A-&gt;B-&gt;A 的过程中,<br>        1. 将A进行增强,获得到增强A给到普通B<br>     A-&gt;B 普通B获取到增强A后进行后置处理器,变为了增强B 此时还没有添加到一级缓存中<br>     A-&gt;B 在执行所有完成后,将增强B添加到单例池中, 此时单例池存在 [增强B,持有增强A],[增强A,没有持有任务]<br>     A    普通A获取到增强B后进行后置处理器,变为了增强A 此时还没有添加到一级缓存中<br>     A    在执行所有完成后,将增强B添加到单例池中, 此时单例池存在 [增强B,持有增强A],[增强A2,增强B]<br>    因为在返回的过程中会将A在此增强, 所以再次的解决方法放入到下方,[引入新问题]<br>      A-&gt;B-&gt;A 的过程中,<br>        1. 将A进行增强,获得到增强A给到普通B,[后置处理器将数据进行了缓存]<br>     A-&gt;B 普通B获取到增强A后进行后置处理器,变为了增强B 此时还没有添加到一级缓存中<br>     A-&gt;B 在执行所有完成后,将增强B添加到单例池中, 此时单例池存在 [增强B,持有增强A1],[增强A1,没有持有任务]<br>     A    普通A获取到增强B后进行后置处理器,[后置处理器早进行了缓存,所以此时拿到的是增强A1]<br>     A    在执行所有完成后,将增强B添加到单例池中, 此时单例池存在 [增强B,持有增强A1],[增强A1,增强B]<br>    此处是解决了分别得到增强A1和A2的问题,但是不满足新的条件[三方循环依赖],讨论放在下方</p><p>case3: A-&gt;B A-&gt;C B-&gt;A C-&gt;A A,B,C都进行了AOP<br>期望: 一级缓存中存在<br>    增强C,持有增强A1<br>    增强B,持有增强A1<br>    增强A,持有增强B<br>    增强A,持有增强C</p><p>什么都不修改</p><p>原因: A-&gt;B-&gt;A 的过程中,<br>        1. 获取到了普通A给到普通B<br>     A-&gt;B 普通B获取到普通A后进行后置处理器,变为了增强B 此时还没有添加到一级缓存中<br>     A-&gt;B 在执行所有完成后,将增强B添加到单例池中, 此时单例池存在 [增强B,持有普通A],[普通A,没有持有任务]<br>     A-&gt;C-&gt;A 的过程中<br>        2. 获取到普通A给到普通C<br>     A-&gt;C 普通C获取到普通A后进行后置处理器,变为了增强C 此时还没有添加到一级缓存中<br>     A-&gt;C 在执行所有完成后,将增强C添加到单例池中, 此时单例池存在 [增强B,持有普通A],[增强C,持有普通A],[普通A,没有持有任务]<br>     A    普通A获取到增强B后进行后置处理器,[后置处理器早进行了缓存,所以此时拿到的是增强A1]<br>     A    在执行所有完成后,将增强B添加到单例池中, 此时单例池存在 [增强B,持有增强A1],[增强A1,增强B]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;spring三级缓存case&quot;&gt;&lt;a href=&quot;#spring三级缓存case&quot; class=&quot;headerlink&quot; title=&quot;spring三级缓存case&quot;&gt;&lt;/a&gt;spring三级缓存case&lt;/h2&gt;&lt;h1 id=&quot;一级缓存&quot;&gt;&lt;a href=&quot;#一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>spring三级缓存流程</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%B5%81%E7%A8%8B/</id>
    <published>2022-10-09T23:36:59.000Z</published>
    <updated>2023-02-08T07:14:52.324Z</updated>
    
    <content type="html"><![CDATA[<p>spring获取一个bean的过程</p><p>getBean-&gt;doGetBean-&gt;</p><ol><li>检查现在是否能获取到一个getSingleTon单例对象<br>1.1 此阶段还没有进入创建流程,所以在getSingleTon中没有获取到一级缓存的Bean则直接放回null&#x3D;&#x3D;&#x3D;&gt;此处的getSingleTon是通过名称获取的, 不管你是什么</li><li>如果能获取到将单例对象返回</li><li>如果不能获取到则执行createBean的流程(该流程比较大)</li></ol><p>createBean流程<br>在org.springframework.beans.factory.support.DefaultSingletonBeanRegistry 内部此流程同样称之为 getSingleTon,携带了一个创建工具的.<br>读作getSingleTon写作createSingleTon getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;)</p><ol><li>将getSingleTon解构后可以得到</li></ol><p>Q: 既然getSingleTon底层就是createBean的操作,那么为什么还需要多次一举呢？<br>A: 之所以需要 getSingleton(java.lang.String, org.springframework.beans.factory.ObjectFactory&lt;?&gt;) 这个步骤,是为了更安全的创建bean对象,诚然ObjectFactory 是createBean的具体流程,但是在创建bean之前需要进行安全校验,<br>    比如下文中的双重锁校验,避免重复创建,获取创建标记锁等步骤</p><p>2.1 双重校验 double check,此处使用锁singleObjects,然后执行<br>   单纯从缓存中是否可以拿到对象,如果可以拿到对象则直接返回. 总做和 doGetBean中的一样.只不过在此流程中的一定是 singleObjects中不存在的</p><p>2.2 开始标记当前正在创建对象, 获取创建对bean的锁 LOCK,使用hashmap记录信号量 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;创建bean锁<br>2.3&#x3D;&#x3D;&#x3D;&gt;开始创建bean</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;spring获取一个bean的过程&lt;/p&gt;
&lt;p&gt;getBean-&amp;gt;doGetBean-&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查现在是否能获取到一个getSingleTon单例对象&lt;br&gt;1.1 此阶段还没有进入创建流程,所以在getSingleTon中没有获取到一级</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>spring循环依赖</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-10-09T23:36:59.000Z</published>
    <updated>2023-02-08T07:14:52.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring循环依赖"><a href="#Spring循环依赖" class="headerlink" title="Spring循环依赖"></a>Spring循环依赖</h1><p>背景: 介绍一个实例创建的经过</p><ol><li>现阶段spring的解决方案</li><li>早期spring的解决方案</li></ol><p>无缓存<br>作用, 解决了什么问题,带来了什么问题?</p><p>一级缓存<br>一级缓存是什么? 解决了什么问题,带来了什么问题?<br>在什么时候时候二级缓存,一级缓存的多种实现</p><p>二级缓存<br>二级缓存是什么? 解决了什么问题,带来了什么问题?<br>在什么时候时候二级缓存,二级缓存的多种实现</p><p>三级缓存<br>三级缓存是什么? 解决了什么问题,带来了什么问题?<br>在什么时候时候三级缓存,三级缓存的多种实现</p><p>结论:</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring循环依赖&quot;&gt;&lt;a href=&quot;#Spring循环依赖&quot; class=&quot;headerlink&quot; title=&quot;Spring循环依赖&quot;&gt;&lt;/a&gt;Spring循环依赖&lt;/h1&gt;&lt;p&gt;背景: 介绍一个实例创建的经过&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;现阶段spring</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>简说spring源码1-spring-bean</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/%E7%AE%80%E8%AF%B4spring%E6%BA%90%E7%A0%81[1]-%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8ABeanFactory/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/%E7%AE%80%E8%AF%B4spring%E6%BA%90%E7%A0%81[1]-%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8ABeanFactory/</id>
    <published>2022-10-09T23:36:59.000Z</published>
    <updated>2023-02-08T07:14:52.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简说spring源码1-spring-bean"><a href="#简说spring源码1-spring-bean" class="headerlink" title="简说spring源码1-spring-bean"></a>简说spring源码1-spring-bean</h1><h2 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h2><p><img src="/./assert/spring-bean%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简说spring源码1-spring-bean&quot;&gt;&lt;a href=&quot;#简说spring源码1-spring-bean&quot; class=&quot;headerlink&quot; title=&quot;简说spring源码1-spring-bean&quot;&gt;&lt;/a&gt;简说spring源码1-sprin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>阅读spring早期源代码</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/%E9%98%85%E8%AF%BBspring%E6%97%A9%E6%9C%9F%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/spring/%E9%98%85%E8%AF%BBspring%E6%97%A9%E6%9C%9F%E6%BA%90%E4%BB%A3%E7%A0%81/</id>
    <published>2022-10-09T23:36:59.000Z</published>
    <updated>2023-02-08T07:14:52.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读spring早期源代码"><a href="#阅读spring早期源代码" class="headerlink" title="阅读spring早期源代码"></a>阅读spring早期源代码</h1><ul><li><a href="#%E9%98%85%E8%AF%BBspring%E6%97%A9%E6%9C%9F%E6%BA%90%E4%BB%A3%E7%A0%81">阅读spring早期源代码</a><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E9%98%85%E8%AF%BB%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA">阅读环境的搭建</a><ul><li><a href="#%E5%87%86%E5%A4%87">准备</a></li></ul></li><li><a href="#%E9%98%85%E8%AF%BB%E8%B5%84%E6%96%99">阅读资料</a><ul><li><a href="#%E6%8E%A8%E8%8D%90%E5%9B%BE%E4%B9%A6">推荐图书</a></li></ul></li></ul></li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>希望通过阅读spring代码,掌握spring对于bean,aop,context等核心功能,有助于基于spring的现有功能进行业务开发以及业务排错.<br>比如: </p><ol><li>了解FactoryBean,可以了解到MyBatis-Spring,dubbo-spring等框架的启动注册流程</li><li>了解BeanFactory,可以了解到Spring对于Bean的生命周期</li><li>了解</li></ol><h2 id="阅读环境的搭建"><a href="#阅读环境的搭建" class="headerlink" title="阅读环境的搭建"></a>阅读环境的搭建</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>jdk1.4,早期代码语法有很多按照现在编译器来看是不合法的的。所以一定要准备好1.4的版本<br><a href="https://www.oracle.com/java/technologies/java-archive-javase-v14-downloads.html">https://www.oracle.com/java/technologies/java-archive-javase-v14-downloads.html</a><br>PS: 不要试图使用1.4版本以上的jdk. 代码中存在使用<code>enum</code>作为<code>标识符</code>的情况,在jdk1.5版本以上<code>enum</code>是作为关键字的</p><p>操作系统:linux, 目前能找到支持的也只有linux和windows有1.4的安装包,为了方便使用linux</p><p>环境变量设置JAVA_HOME</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/ubuntu/downloads/j2sdk1.4.2_19 </span><br><span class="line">export PATH=$JAVA_HOME/bin:$JAVA_HOME/lib:$PATH</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证</span></span><br><span class="line">java -version </span><br></pre></td></tr></table></figure><p>设置ant环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANT_HOME=./lib/ant</span><br></pre></td></tr></table></figure><p>编译代码<br>早期spring使用ant作为构建代码的工具, 其中在项目中已经含有了可以构建当前1.4版本的ant工具 在<code>./lib/ant</code> 中<br>或者自行下载安装ant1.6.1的版本</p><p>Apache Ant version 1.6.1 compiled on February 12 2004</p><p>编写build.sh脚本用作后续方便操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># replace JAVA_HOME with jdk1.4</span></span><br><span class="line"><span class="comment"># export JAVA_HOME_4=~/downloads/j2sdk1.4.2_19</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $1 param</span></span><br><span class="line"><span class="comment">## eg: modulejars package all module</span></span><br><span class="line"><span class="comment">## eg: srczip package all source to zip</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$JAVA_HOME_4</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">export</span> JAVA_HOME=<span class="variable">$JAVA_HOME_4</span></span><br><span class="line">  <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">jvm_jar=<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">ant_jar=./lib/ant/ant.jar:./lib/ant/ant-launcher.jar:./lib/ant/ant-trax.jar:./lib/ant/ant-junit.jar</span><br><span class="line">junit_jar=./lib/junit/junit.jar</span><br><span class="line">clover_jar=./lib/clover/clover.jar</span><br><span class="line"></span><br><span class="line">startup_jar=<span class="variable">$jvm_jar</span>:<span class="variable">$ant_jar</span>:<span class="variable">$junit_jar</span>:<span class="variable">$clover_jar</span></span><br><span class="line"><span class="variable">$JAVA_HOME</span>/bin/java -<span class="built_in">cp</span> <span class="variable">$startup_jar</span>  org.apache.tools.ant.Main <span class="variable">$1</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/ubuntu/downloads/j2sdk1.4.2_19</span><br><span class="line">export PATH=$JAVA_HOME/bin:$JAVA_HOME/lib:$PATH </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包源代码</span></span><br><span class="line">./build.sh srczip </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按照模块编译代码</span></span><br><span class="line">./build.sh modulejars</span><br></pre></td></tr></table></figure><h2 id="阅读资料"><a href="#阅读资料" class="headerlink" title="阅读资料"></a>阅读资料</h2><h3 id="推荐图书"><a href="#推荐图书" class="headerlink" title="推荐图书"></a>推荐图书</h3><ul><li>J2EE设计开发编程指南(Expert One-on-One J2EE Design and Development)<br>推荐原因: spring设计时参考的设计指南,对于理解spring的设计思路有帮助</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读spring早期源代码&quot;&gt;&lt;a href=&quot;#阅读spring早期源代码&quot; class=&quot;headerlink&quot; title=&quot;阅读spring早期源代码&quot;&gt;&lt;/a&gt;阅读spring早期源代码&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%98%85%</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis淘汰策略实现</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/redis%E4%B8%93%E9%A2%98/redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/redis%E4%B8%93%E9%A2%98/redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-10-09T23:33:04.000Z</published>
    <updated>2023-02-08T07:14:52.272Z</updated>
    
    <content type="html"><![CDATA[<p>freeMemoryIfNeeded</p><p>“ Aloha Heja He 20:38:43<br>为什么倒序淘汰key “<br>用的空闲时间 idleTime 策略.</p><p>LRU,LFU,TTL策略 共性使用 idle空闲时间去讨论。即需要去除</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;freeMemoryIfNeeded&lt;/p&gt;
&lt;p&gt;“ Aloha Heja He 20:38:43&lt;br&gt;为什么倒序淘汰key “&lt;br&gt;用的空闲时间 idleTime 策略.&lt;/p&gt;
&lt;p&gt;LRU,LFU,TTL策略 共性使用 idle空闲时间去讨论。即需要去除&lt;/p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>sdkman操作-使用本地包</title>
    <link href="http://jev001.github.io/2022/10/09/%E6%9D%82/sdkman%E6%93%8D%E4%BD%9C-%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%8C%85/"/>
    <id>http://jev001.github.io/2022/10/09/%E6%9D%82/sdkman%E6%93%8D%E4%BD%9C-%E4%BD%BF%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%8C%85/</id>
    <published>2022-10-09T23:23:07.000Z</published>
    <updated>2023-02-08T07:14:52.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sdkman操作-使用本地包"><a href="#sdkman操作-使用本地包" class="headerlink" title="sdkman操作-使用本地包"></a>sdkman操作-使用本地包</h1><p>背景: sdkman官方提供的包渠道存在缺失的可能,sdkman提供了一种使用本地包提交给其管理的模式</p><p>sdk man install version-calssname path<br>sdk man install 1.8-oracle &#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_202.jdk&#x2F;Contents&#x2F;Home</p><p>1.8-oracle 分为1.8的版本和oracle的classname, 其中classname具有区分标签的功能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sdkman操作-使用本地包&quot;&gt;&lt;a href=&quot;#sdkman操作-使用本地包&quot; class=&quot;headerlink&quot; title=&quot;sdkman操作-使用本地包&quot;&gt;&lt;/a&gt;sdkman操作-使用本地包&lt;/h1&gt;&lt;p&gt;背景: sdkman官方提供的包渠道存在缺失</summary>
      
    
    
    
    
    <category term="杂" scheme="http://jev001.github.io/tags/%E6%9D%82/"/>
    
  </entry>
  
  <entry>
    <title>cvs2svn安装以及将cvs转成git步骤</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/cvs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/cvs2svn%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B0%86cvs%E8%BD%AC%E6%88%90git%E6%AD%A5%E9%AA%A4/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/cvs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/cvs2svn%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B0%86cvs%E8%BD%AC%E6%88%90git%E6%AD%A5%E9%AA%A4/</id>
    <published>2022-10-09T23:23:07.000Z</published>
    <updated>2023-02-08T07:14:52.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将cvs仓库转换成git仓库"><a href="#将cvs仓库转换成git仓库" class="headerlink" title="将cvs仓库转换成git仓库"></a>将cvs仓库转换成git仓库</h1><p>下载 cvs2svn<br>ubuntu环境下未找到现成的二进制工具,只能通过自行编译安装了<br>代码源地址 <a href="https://github.com/mhagger/cvs2svn">https://github.com/mhagger/cvs2svn</a><br>wget <a href="https://github.com/mhagger/cvs2svn/releases/download/2.5.0/cvs2svn-2.5.0.tar.gz">https://github.com/mhagger/cvs2svn/releases/download/2.5.0/cvs2svn-2.5.0.tar.gz</a></p><p>解压代码<br>tar -zxvf cvs2svn-2.5.0.tar.gz</p><p>编译前准备</p><ol><li>环境依赖, python2 ☆☆☆☆☆,<br>python3环境下不支持,官网有指出,为了编译成功确保本地环境的python指向python2<br>ln -s &#x2F;usr&#x2F;bin&#x2F;python2 &#x2F;usr&#x2F;bin&#x2F;python</li><li>cvs客户端<br>ubuntu环境下一般通过下载就能解决<br><code>sudo apt install cvs</code></li></ol><p>编译代码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;将cvs仓库转换成git仓库&quot;&gt;&lt;a href=&quot;#将cvs仓库转换成git仓库&quot; class=&quot;headerlink&quot; title=&quot;将cvs仓库转换成git仓库&quot;&gt;&lt;/a&gt;将cvs仓库转换成git仓库&lt;/h1&gt;&lt;p&gt;下载 cvs2svn&lt;br&gt;ubuntu环境</summary>
      
    
    
    
    
    <category term="cvs基本操作" scheme="http://jev001.github.io/tags/cvs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
    <category term="csv" scheme="http://jev001.github.io/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>将cvs仓库转换成git仓库</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/cvs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/cvs2svn%E8%BD%AC%E6%8D%A2/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/cvs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/cvs2svn%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-10-09T23:23:07.000Z</published>
    <updated>2023-02-08T07:14:52.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将cvs仓库转换成git仓库"><a href="#将cvs仓库转换成git仓库" class="headerlink" title="将cvs仓库转换成git仓库"></a>将cvs仓库转换成git仓库</h1><p><a href="https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2svn.html">https://www.mcs.anl.gov/~jacob/cvs2svn/cvs2svn.html</a></p><p>下载 cvs2svn<br>ubuntu环境下未找到现成的二进制工具,只能通过自行编译安装了<br>代码源地址 <a href="https://github.com/mhagger/cvs2svn">https://github.com/mhagger/cvs2svn</a><br>wget <a href="https://github.com/mhagger/cvs2svn/releases/download/2.5.0/cvs2svn-2.5.0.tar.gz">https://github.com/mhagger/cvs2svn/releases/download/2.5.0/cvs2svn-2.5.0.tar.gz</a></p><p>解压代码<br>tar -zxvf cvs2svn-2.5.0.tar.gz</p><p>编译前准备</p><ol><li>环境依赖, python2 ☆☆☆☆☆,<br>python3环境下不支持,官网有指出,为了编译成功确保本地环境的python指向python2<br>ln -s &#x2F;usr&#x2F;bin&#x2F;python2 &#x2F;usr&#x2F;bin&#x2F;python</li><li>cvs客户端<br>ubuntu环境下一般通过下载就能解决<br><code>sudo apt install cvs</code></li></ol><p>编译代码<br>make man<br>make check<br>sudo make install</p><p>编译成功后一般会在 &#x2F;usr&#x2F;local&#x2F;bin 下生成<code>cvs2git</code>,<code>cvs2svn</code>,<code>cvs2bzr</code><br><img src="/./asserts/cvs2svn%E5%AE%89%E8%A3%85%E5%AE%8C%E6%88%90.png"></p><p>将cvs仓库导出成git仓库</p><ul><li>部分log message 或者author名称或者其他导致编码导出错误的可以参考 python2标准编码格式然后指定–encoding 就可以了,如果还是失败还可以指定 –fallback-encoding&#x3D;UTF8</li></ul><p>错误编码将终止流程的命令<br>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;cvs2git –blobfile&#x3D;.&#x2F;git-blob.dat –dumpfile&#x3D;.&#x2F;git-dump.dat –username&#x3D;cvsd  &#x2F;var&#x2F;lib&#x2F;cvsd&#x2F;spring-cvs</p><p>容错错误编码执行的命令</p><p>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;cvs2git   –blobfile&#x3D;.&#x2F;git-blob.dat –dumpfile&#x3D;.&#x2F;git-dump.dat –encoding&#x3D;UTF8 –fallback-encoding&#x3D;UTF8 –username&#x3D;cvsd  &#x2F;var&#x2F;lib&#x2F;cvsd&#x2F;spring-cvs&#x2F;spring</p><p>将git二进制数据转换成成git仓库文件</p><p>准备git仓库<br>执行 git init –bare 将仓库转换成bare型,不指定–bare也是可以的<br>git fast-import –export-marks&#x3D;.&#x2F;git-marks.dat &lt; ..&#x2F;cvs2git&#x2F;git-blob.dat</p><p>git fast-import –import-marks&#x3D;.&#x2F;git-marks.dat &lt; ..&#x2F;cvs2git&#x2F;git-dump.dat</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;将cvs仓库转换成git仓库&quot;&gt;&lt;a href=&quot;#将cvs仓库转换成git仓库&quot; class=&quot;headerlink&quot; title=&quot;将cvs仓库转换成git仓库&quot;&gt;&lt;/a&gt;将cvs仓库转换成git仓库&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.m</summary>
      
    
    
    
    
    <category term="cvs基本操作" scheme="http://jev001.github.io/tags/cvs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
    <category term="csv" scheme="http://jev001.github.io/tags/csv/"/>
    
  </entry>
  
  <entry>
    <title>阅读spring早期源码-cvs</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/cvs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/%E9%98%85%E8%AF%BBspring%E6%97%A9%E6%9C%9F%E6%BA%90%E7%A0%81/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/cvs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/%E9%98%85%E8%AF%BBspring%E6%97%A9%E6%9C%9F%E6%BA%90%E7%A0%81/</id>
    <published>2022-10-09T23:23:07.000Z</published>
    <updated>2023-02-08T07:14:52.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读spring早期源码-cvs"><a href="#阅读spring早期源码-cvs" class="headerlink" title="阅读spring早期源码-cvs"></a>阅读spring早期源码-cvs</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul><li>最近想了解spring最初的代码设计方式,遂在github找寻了一番无果后,查找到spring代码原提交在<code>sourceforge.net</code>中,并且有一些mailing list能在内做参考</li></ul><p>项目主页: <a href="https://sourceforge.net/p/springframework">https://sourceforge.net/p/springframework</a><br>仓库主页: <a href="https://sourceforge.net/p/springframework/cvs">https://sourceforge.net/p/springframework/cvs</a><br>邮件主页: <a href="https://sourceforge.net/p/springframework/mailman/">https://sourceforge.net/p/springframework/mailman/</a></p><ul><li>本文则是为了阅读spring代码而进行的步骤</li></ul><h2 id="在线阅读"><a href="#在线阅读" class="headerlink" title="在线阅读"></a>在线阅读</h2><p>spring提供了<code>cvs</code>匿名只读访问的地址<br>cvs是一种和git类似的版本管理工具</p><h3 id="使用IDE插件工具查看"><a href="#使用IDE插件工具查看" class="headerlink" title="使用IDE插件工具查看"></a>使用IDE插件工具查看</h3><p>cvs是较早期的开发出来的管理工具,并且该项目很久没有更新了,各大IDE的插件出现了不支持的现象<br>  截止2022-07-16,常用的idea、eclipse等新版IDE是不支持的(阅读兼容问题),<br>  所以推荐在idea2015或者是eclipse2015(mars)版本中安装cvs插件,安装插件方式和普通安装插件方式一样</p><p><code>pserver:anonymous@springframework.cvs.sourceforge.net:/cvsroot/springframework</code><br>使用idea或者eclipse 带入使用该地址即可访问项目目录, 选择spring-project即可</p><h3 id="使用命令行"><a href="#使用命令行" class="headerlink" title="使用命令行"></a>使用命令行</h3><p>cvs -z3 -d:pserver:<a href="mailto:&#x61;&#110;&#x6f;&#110;&#121;&#109;&#x6f;&#x75;&#x73;&#x40;&#97;&#46;&#x63;&#118;&#115;&#x2e;&#x73;&#111;&#117;&#114;&#99;&#101;&#102;&#111;&#114;&#x67;&#101;&#46;&#110;&#x65;&#x74;">&#x61;&#110;&#x6f;&#110;&#121;&#109;&#x6f;&#x75;&#x73;&#x40;&#97;&#46;&#x63;&#118;&#115;&#x2e;&#x73;&#111;&#117;&#114;&#99;&#101;&#102;&#111;&#114;&#x67;&#101;&#46;&#110;&#x65;&#x74;</a>:&#x2F;cvsroot&#x2F;springframework co -P Attic<br>cvs -z3 -d:pserver:<a href="mailto:&#97;&#x6e;&#x6f;&#110;&#121;&#x6d;&#x6f;&#117;&#115;&#x40;&#97;&#46;&#99;&#118;&#x73;&#46;&#115;&#x6f;&#117;&#x72;&#x63;&#101;&#102;&#x6f;&#114;&#103;&#x65;&#46;&#110;&#101;&#116;">&#97;&#x6e;&#x6f;&#110;&#121;&#x6d;&#x6f;&#117;&#115;&#x40;&#97;&#46;&#99;&#118;&#x73;&#46;&#115;&#x6f;&#117;&#x72;&#x63;&#101;&#102;&#x6f;&#114;&#103;&#x65;&#46;&#110;&#101;&#116;</a>:&#x2F;cvsroot&#x2F;springframework co -P i21<br>cvs -z3 cvs -z3 -d:pserver:<a href="mailto:&#97;&#110;&#x6f;&#110;&#x79;&#x6d;&#111;&#x75;&#115;&#64;&#97;&#x2e;&#x63;&#118;&#x73;&#46;&#x73;&#111;&#117;&#x72;&#99;&#x65;&#x66;&#x6f;&#114;&#103;&#101;&#x2e;&#x6e;&#101;&#x74;">&#97;&#110;&#x6f;&#110;&#x79;&#x6d;&#111;&#x75;&#115;&#64;&#97;&#x2e;&#x63;&#118;&#x73;&#46;&#x73;&#111;&#117;&#x72;&#99;&#x65;&#x66;&#x6f;&#114;&#103;&#101;&#x2e;&#x6e;&#101;&#x74;</a>:&#x2F;cvsroot&#x2F;springframework co -P samples<br>cvs -z3 -d:pserver:<a href="mailto:&#97;&#110;&#111;&#x6e;&#x79;&#x6d;&#x6f;&#x75;&#x73;&#x40;&#x61;&#46;&#99;&#118;&#x73;&#46;&#115;&#111;&#117;&#x72;&#99;&#101;&#102;&#x6f;&#114;&#103;&#x65;&#46;&#x6e;&#101;&#116;">&#97;&#110;&#111;&#x6e;&#x79;&#x6d;&#x6f;&#x75;&#x73;&#x40;&#x61;&#46;&#99;&#118;&#x73;&#46;&#115;&#111;&#117;&#x72;&#99;&#101;&#102;&#x6f;&#114;&#103;&#x65;&#46;&#x6e;&#101;&#116;</a>:&#x2F;cvsroot&#x2F;springframework co -P spring-beandoc<br>cvs -z3 -d:pserver:<a href="mailto:&#97;&#110;&#x6f;&#x6e;&#x79;&#x6d;&#x6f;&#117;&#115;&#x40;&#97;&#46;&#x63;&#x6d;&#111;&#117;&#x73;">&#97;&#110;&#x6f;&#x6e;&#x79;&#x6d;&#x6f;&#117;&#115;&#x40;&#97;&#46;&#x63;&#x6d;&#111;&#117;&#x73;</a>@a.cvs.sourceforge.net:&#x2F;cvsroot&#x2F;springframework co -P spring-projects</p><h2 id="搭建本地cvs仓库"><a href="#搭建本地cvs仓库" class="headerlink" title="搭建本地cvs仓库"></a>搭建本地cvs仓库</h2><ul><li>只是阅读代码使用在线阅读就可以了. 如果还想提交代码呢, 因为原始仓库只提供了只读功能,所以要不就提交申请账号,要么本地搭建项目了<ul><li>好彩spring-cvs主页中有提供完整的仓库镜像同步</li></ul></li></ul><p>官方提供cvs停用说明  <a href="https://sourceforge.net/blog/decommissioning-cvs-for-commits/">https://sourceforge.net/blog/decommissioning-cvs-for-commits/</a></p><p><a href="http://springframework.cvs.sourceforge.net/">http://springframework.cvs.sourceforge.net/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rsync -a a.cvs.sourceforge.net::cvsroot/springframewogframework/</span><br><span class="line">rsync -ai a.cvs.sourceforge.net::cvsroot/springframework/ /my/local/dest/dir/</span><br><span class="line">If you are a project admin for springframework, you can request that this page redirect to another repo on your project by submitting a</span><br></pre></td></tr></table></figure><h3 id="安装服务器版本"><a href="#安装服务器版本" class="headerlink" title="安装服务器版本"></a>安装服务器版本</h3><p>cvs 本身是支持client和server模式两种的, 为方便访问仓库使用cvsd挂载后台程序的方式进行管理</p><ol><li>安装cvsd工具<br>sudo apt install cvsd</li><li>将 刚刚同步的spring-cvs 复制到 &#x2F;var&#x2F;lib&#x2F;cvsd 目录中(此步骤可以省略,为了简化cvsd配置信息故放此处,如果需要放入其他目录,需要了解cvs权限和cvs用户相关知识)</li><li>编辑 &#x2F;etc&#x2F;cvsd&#x2F;cvsd.ini 配置文件添加 <code>Repos /spring-cvs</code></li><li>增加或者编辑spring-cvs中配置的访问用户(为方便访问,去除匿名成员组合密码)</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前 anoncvs_springframework 为用户分组,因为本地安装的cvsd创建的是`anoncvs_springframework`cvsd用户,所以指定单独仓库时针对仓库的访问用户指定转发的cvsd用户</span></span><br><span class="line"><span class="comment">## $1$0H$2/LSjjwDfsSA0gaDYY5Df/ 这个为访问密码因为未知所以直接去除</span></span><br><span class="line">anonymous1:$1$0H$2/LSjjwDfsSA0gaDYY5Df/:anoncvs_springframework</span><br><span class="line"><span class="comment"># 修改后</span></span><br><span class="line">anonymous::cvsd</span><br></pre></td></tr></table></figure><ol start="5"><li>去除只读权限,增加可写权限</li></ol><ul><li>cvs 可以配置当前仓库的<code>只读</code>和<code>可写</code>用户在<code>spring-cvs/CVSROOT/readers</code>和<code>spring-cvs/CVSROOT/writer</code>中<ul><li>cvs会有限判断用户是否在reader中,此文件中的为只读用户,就算此用户在<code>writer</code>文件中,也认为是只读</li></ul></li></ul><ol start="6"><li><p>编辑<code>spring-cvs/CVSROOT/loginfo</code>文件去除<code>loginfo</code>中的同步review邮件(可选,cvs对于提交的记录会发送给,spring项目组进行review)</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">DEFAULT /cvsroot/sitedocs/CVSROOT/cvstools/syncmail %&#123;sVv&#125; springframework-cvs@lists.sourceforge.net</span><br><span class="line"><span class="comment"># 修改后 删除或注释</span></span><br><span class="line"><span class="comment"># DEFAULT /cvsroot/sitedocs/CVSROOT/cvstools/syncmail %&#123;sVv&#125; springframework-cvs@lists.sourceforge.net</span></span><br></pre></td></tr></table></figure></li><li><p>编辑<code>spring-cvs/CVSROOT/commitinfo</code> 去除提交规范(可选,cvs在提交时可以强制校验提交message是否符合要求)</p></li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改前</span></span><br><span class="line">ALL /cvsroot/sitedocs/CVSROOT/keepsake -p springframework</span><br><span class="line"><span class="comment"># 修改后 删除或者注释</span></span><br><span class="line"><span class="comment"># ALL /cvsroot/sitedocs/CVSROOT/keepsake -p springframework</span></span><br></pre></td></tr></table></figure><p>至此就已经可以在本地服务器上提交代码了,</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul><li>因本人习惯git操作,所以使用 cvs2git将cvs信息转换成git信息放入了仓库中<ul><li><code>cvs2git</code>是经过<code>cvs2svn项目</code>编译而来的. 这个项目会生成转换多种项目的工具<code>cvs2svn</code>,<code>cvs2git</code>等</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅读spring早期源码-cvs&quot;&gt;&lt;a href=&quot;#阅读spring早期源码-cvs&quot; class=&quot;headerlink&quot; title=&quot;阅读spring早期源码-cvs&quot;&gt;&lt;/a&gt;阅读spring早期源码-cvs&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="cvs基本操作" scheme="http://jev001.github.io/tags/cvs%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    
    <category term="csv" scheme="http://jev001.github.io/tags/csv/"/>
    
    <category term="spring" scheme="http://jev001.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>排查cpp语言中引用传递和值传递的区分</title>
    <link href="http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/%E6%8E%92%E6%9F%A5cpp%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%86/%E6%8E%92%E6%9F%A5cpp%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%86/"/>
    <id>http://jev001.github.io/2022/10/09/%E4%B8%93%E9%A2%98/%E6%8E%92%E6%9F%A5cpp%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%86/%E6%8E%92%E6%9F%A5cpp%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%86/</id>
    <published>2022-10-09T23:00:14.000Z</published>
    <updated>2023-02-08T07:14:52.344Z</updated>
    
    <content type="html"><![CDATA[<p>java使用的是 指针传递, 不是指传递,也不是引用传递.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java使用的是 指针传递, 不是指传递,也不是引用传递.&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>查看java运行中的汇编</title>
    <link href="http://jev001.github.io/2022/08/16/%E6%9F%A5%E7%9C%8Bjava%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96/"/>
    <id>http://jev001.github.io/2022/08/16/%E6%9F%A5%E7%9C%8Bjava%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96/</id>
    <published>2022-08-16T03:21:09.000Z</published>
    <updated>2023-02-08T07:14:52.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用命令行查看汇编"><a href="#使用命令行查看汇编" class="headerlink" title="使用命令行查看汇编"></a>使用命令行查看汇编</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 使用jitwatch查看汇编</span><br><span class="line"></span><br><span class="line">* 项目地址:https://github.com/AdoptOpenJDK/jitwatch</span><br><span class="line">* Mac应用下载地址:https://github.com/AdoptOpenJDK/jitwatch/releases/download/1.4.7/jitwatch-ui-1.4.7-shaded-mac.jar</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#96;&#96;&#96;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用命令行查看汇编&quot;&gt;&lt;a href=&quot;#使用命令行查看汇编&quot; class=&quot;headerlink&quot; title=&quot;使用命令行查看汇编&quot;&gt;&lt;/a&gt;使用命令行查看汇编&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用calibre去除DRM</title>
    <link href="http://jev001.github.io/2022/08/13/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8calibre%E5%8E%BB%E9%99%A4DRM/"/>
    <id>http://jev001.github.io/2022/08/13/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8calibre%E5%8E%BB%E9%99%A4DRM/</id>
    <published>2022-08-13T04:22:23.000Z</published>
    <updated>2023-02-08T07:14:52.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="DRM是什么"><a href="#DRM是什么" class="headerlink" title="DRM是什么"></a>DRM是什么</h3><p>下文摘抄自百度百科 <a href="https://baike.baidu.com/item/DRM/863505">https://baike.baidu.com/item/DRM/863505</a></p><blockquote><p>DRM，英文全称Digital Rights Management, 可以翻译为：数字版权管理。 数字版权管理是指数字内容，如音视频节目内容、文档、电子书籍等在生产、传播、销售、使用过程中 进行的权利保护、使用控制与管理的技术。</p></blockquote><h3 id="为什么需要去除DRM"><a href="#为什么需要去除DRM" class="headerlink" title="为什么需要去除DRM"></a>为什么需要去除DRM</h3><ul><li>上述中解释了<code>DRM</code>的作用, 但这个真的是对的吗？<br>例子:</li></ul><ol><li>现实生活, 在A书店购买的书籍, 可以借给同学看, 也可以放在跳蚤市场上专卖, 提高实体书的流通率.</li><li>在kindle上购买的书籍, 只能用在kindle设备上查看.不能专卖, 也不能借给其他人(从设备中导出提供给其他人)。</li></ol><p>由上述例子2中可以看到,电子书不能导出给其他人, 而限制不能导出使用到其他设备的<code>手段</code>,就是DRM</p><h3 id="如何去除DRM"><a href="#如何去除DRM" class="headerlink" title="如何去除DRM"></a>如何去除DRM</h3><ul><li>主要是借助DeDRM工具,下载地址:<a href="https://github.com/apprenticeharper/DeDRM_tools/releases">https://github.com/apprenticeharper/DeDRM_tools/releases</a></li><li>教程:<a href="https://bookfere.com/post/6.html">https://bookfere.com/post/6.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;h3 id=&quot;DRM是什么&quot;&gt;&lt;a href=&quot;#DRM是什么&quot; class=&quot;headerlink&quot; title=&quot;DRM是什么&quot;&gt;&lt;/a&gt;D</summary>
      
    
    
    
    
    <category term="电子书" scheme="http://jev001.github.io/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>rocket存储引擎[4]-查询index文件</title>
    <link href="http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocket%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E[4]-%E6%9F%A5%E8%AF%A2index%E6%96%87%E4%BB%B6/"/>
    <id>http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocket%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E[4]-%E6%9F%A5%E8%AF%A2index%E6%96%87%E4%BB%B6/</id>
    <published>2022-05-02T23:00:18.000Z</published>
    <updated>2023-02-08T07:14:52.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查询Index文件"><a href="#查询Index文件" class="headerlink" title="查询Index文件"></a>查询Index文件</h2><span id="more"></span> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">20220502</span>]-commitLog文件初探四-查询Index索引文件。</span><br><span class="line"></span><br><span class="line">在`commitlog文件初探三-构建Index索引文件`中有介绍index文件构成其中包括 内容index,diffTime,keyHash等,还介绍了index文件本质上是一个hashmap在文件上的表示.</span><br><span class="line">在上次遗留了几个点</span><br><span class="line"><span class="number">1.</span> diffTime是做什么的?为什么要存储这个数据?可以不存储这个数据吗?</span><br><span class="line"><span class="number">2.</span> index是如何处理hash冲突的?</span><br><span class="line"><span class="number">3.</span> 为什么index文件的中处理hash冲突采用的是头插法?尾插法不可以吗?</span><br><span class="line"><span class="number">4.</span> 多并发写index文件.</span><br><span class="line"><span class="number">5.</span> 为什么index文件要持有资源引用数据 resourceRefCount</span><br><span class="line"></span><br><span class="line">针对以上问题的解释:</span><br><span class="line"><span class="number">1.</span> diffTime上次简单描述了作用是作为一个 回收数据时的一句,可以针对历史久远数据进行回收. 这个概念如果放在多个文件中,或者是内存概念中是合理的, 但是放在单文件中, 不合理的地方凸显出来了. 那就是diffTime原则上是递增的.</span><br><span class="line">  <span class="number">1</span>). 新数据一定会大于老数据的DiffTime.</span><br><span class="line">  <span class="number">2</span>). 新数据是追加在老数据行后的.</span><br><span class="line">根据这两个特性, 如果作为回收数据依靠, 那么就只有回写indexCount的情况下才会使用到前置数据了, 不然将导致多次一举的可能.但是indexCount又是一直递增的. 所以这个可能性被驳回了。</span><br><span class="line">那么还有什么可能吗? 答案是有的, 那就是按照时间存储数据,新增数据diffTime越大. 越靠后</span><br><span class="line"><span class="number">2.</span> index中处理hash冲突的办法就是将针对到slot_index的数据制作成链表结构[拉链法],但是针对hashKey一样的数据没有做额外的处理.  ☆☆☆☆☆</span><br><span class="line">   之前有讲过index是一个hashmap文件化的表示. 但是这部分只是针对于解决冲突的前半部分. 后半部分对于持有同样的hashKey将新增一样的记录</span><br><span class="line">   那么问题就来了. 如果两个key不一样,但是keyHash一样. 那么在index中会存在几条数据? 答案是两条,index文件不会去做[去重]的动作。</span><br><span class="line"><span class="number">3.</span> index文件采用头插法是为什么呢? 这个是一个经验值普遍业务做法. 这个关键因素在于diffTime.</span><br><span class="line">   根据上文<span class="number">1.</span>提到diffTime新数据,数值越大. 按照时间范围查询的时候,获取新数据比获取旧数据更可靠. 此外在做查询`selectPhyOffset`时,有一个maxNum,如果从旧数据查询, 那么就无法获取到最新数据了。</span><br><span class="line"><span class="number">4.</span> 此前rocketmq对于index文件并发写是做了文件锁的,但是后续将这部分代码注释掉了,原因可能是影响了读写性能了===&gt;大部分情况下是不会出现这个并发错误的,因为目前看来只有一个RePutService 线程在对这个文件写入。. 文件行锁 使用的是FileLock.针对某个 地址,这个地址在rocketmq中选用的是 每个索引行的起始地址. 使用起始地址也是结合上文的索引行固定行大小的结果</span><br><span class="line"><span class="number">5.</span> 资源引用数据, 个人认为是为了index文件过期删除做准备的.</span><br><span class="line">  盲猜这个过期删除步骤是一个新的线程操作. 如果有index文件写/查 的过程中进行删除,那么将无法获取到准确数据,所以在使用到该index文件时,就进行类似上锁的操作. 在做清除工作的时候略过该文件. 清理下一个文件.</span><br><span class="line"></span><br><span class="line">本次阅读重点:</span><br><span class="line">    在解释头插法的时候.有一个重要的概念【归纳法】</span><br><span class="line">    <span class="number">1.</span> 在查询一个范围数据中. 如果该数据集是有序的. 那么 假设 A集合中有a1,a2,a3,a4,a5 其中a3,不符合规则,那么a4,a5也同样不符合规则,就不需要查询了</span><br><span class="line">    这一点针对 diffTime的时间范围查询.</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 批量查询对应key中的索引信息.</span></span><br><span class="line">     <span class="comment">// 使用#phyOffsets变量透出, 这部分本来可以使用返回值的. 使用共享变量可以减少list的创建以及多list合并情况。, maxNum表示当前查询的消息最大个数</span></span><br><span class="line">     <span class="comment">// begin和end 表示查询索引的时间范围. 索引有效时间根据 index存储的索引行内容diffTime记录, 该记录使用的是 相对于index的beginTime的时间.</span></span><br><span class="line">     <span class="comment">// 然后就是查询方式是按照hash的方式查询的</span></span><br><span class="line">     <span class="comment">// 当出现了hash一样的情况下, 也将数据返回, 目前需要做的是粗略的定位, 不需要做精准定位</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">//  hash_slot[1]=content0_index =&gt; hash_slot[1]=content1_index =&gt; hash_slot[1]=content2_index =&gt; hash_slot[1]=content2_index</span></span><br><span class="line">     <span class="comment">//  ===&gt;hash_slot[1]=content3_index===&gt;hash_slot[1]=content4_index===&gt;hash_slot[1]=content5_index===&gt;hash_slot[1]=content6_index</span></span><br><span class="line">     <span class="comment">//  ===&gt;hash_slot[1]=content7_index</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">//         |-------------[hash_slot[1]]--------------------------------------|</span></span><br><span class="line">     <span class="comment">//         | 索引行,行标index_count|内容   |hash值|上一个索引行,航标   |diff_time</span></span><br><span class="line">     <span class="comment">//         |content0_index|content0_data|keyHash_0|-1            |  01 |</span></span><br><span class="line">     <span class="comment">//         |content1_index|content1_data|keyHash_1|content0_index|  10 |</span></span><br><span class="line">     <span class="comment">//         |content2_index|content2_data|keyHash_2|content1_index|  20 |</span></span><br><span class="line">     <span class="comment">//         |content3_index|content3_data|keyHash_3|content2_index|  30 |</span></span><br><span class="line">     <span class="comment">//         |content4_index|content4_data|keyHash_1|content3_index|  40 |</span></span><br><span class="line">     <span class="comment">//         |content5_index|content5_data|keyHash_2|content4_index|  50 |</span></span><br><span class="line">     <span class="comment">//         |content6_index|content6_data|keyHash_3|content5_index|  60 |</span></span><br><span class="line">     <span class="comment">//         |content7_index|content7_data|keyHash_1|content6_index|  70 |</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 按照图中所给 其中按照头插法, 最终记录在索引头的hash_slot[1]为content7_index的行号</span></span><br><span class="line">     <span class="comment">// 其中数据按照 keyHash_0,keyHash_1,keyHash_2,keyHash_3 真实hash值存储在索引行中。</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 在需要查询具体数据的时候</span></span><br><span class="line">     <span class="comment">//  1. 查询出具体的slot_index找到索引行.</span></span><br><span class="line">     <span class="comment">//  2. 按照索引行给出的单链表, 将逐个遍历下去, 找到和搜索key_hash相等的索引行(☆☆☆☆☆☆☆)</span></span><br><span class="line">     <span class="comment">//  2.1 按照索引行给出数据查找到后不会立即返回, 会继续按照索引行的链表方向查找到最底部.</span></span><br><span class="line">     <span class="comment">//  2.2 虽说上述描述的会按照链表的方向一直查询下去, 但是当查询到time不符合了就会停止搜索====&gt;这里面有一个很重要的概念为。</span></span><br><span class="line">     <span class="comment">//  数据是按照头插法插入的, 也就是说最顶部的为最新数据, 只要其中一项不符合时间范围, 之后的一定会不符合时间范围.</span></span><br><span class="line">     <span class="comment">//  即 头插法不仅仅是index坐标的倒叙, 更是插入时间的倒叙方式. 那么按照头插法是很合理的要求了。</span></span><br><span class="line">     <span class="comment">//     如果按照尾插法===&gt;虽然可以解决hash冲突的情况,但是使用时间搜索的时候. 就必须先遍历久远的数据再遍历新数据.</span></span><br><span class="line">     <span class="comment">//     极端场景下查询的数据范围更加的靠后, 并且该链路很长, 就花费了很多无用功。=====&gt; 那么这个是经验值吗？</span></span><br><span class="line">     <span class="comment">//  所以 这部分可以使用数学中的【归纳法】对后续的数据进行假设,得出结论</span></span><br><span class="line">     <span class="comment">//  3.将符合条件的物理地址填充到 集合中返回</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 按照上述步骤</span></span><br><span class="line">     <span class="comment">//   查询一个 key 其keyHash 为 keyHash_1 .那么就会进行遍历, 假设时间查询截止到 100~50</span></span><br><span class="line">     <span class="comment">//   从 content7_index开始. 因为这个值是存放在slot_index[1]中的. 符合条件添加[keyHash]符合,[diffTime]符合</span></span><br><span class="line">     <span class="comment">//   遍历 content6_index.  不符合条件,[keyHash]不符合,[diffTime]符合</span></span><br><span class="line">     <span class="comment">//   遍历 content5_index.  不符合条件,[keyHash]不符合,[diffTime]符合</span></span><br><span class="line">     <span class="comment">//   遍历 content4_index.  不符合条件,[keyHash]符合,[diffTime]符合, 因为时间不符合</span></span><br><span class="line">     <span class="comment">//   归纳假设, 因为content4_index中时间不符合, 又因为content4_index中事件均大于 content3,content2,content1,content0,所以下方不需要进行遍历</span></span><br><span class="line">     <span class="comment">//</span></span><br><span class="line">     <span class="comment">// 根据上述步骤 可以查询到的有效数据为 content7_index中的物理地址了。</span></span><br><span class="line">     <span class="comment">//</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectPhyOffset</span><span class="params">(<span class="keyword">final</span> List&lt;Long&gt; phyOffsets, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">int</span> maxNum,</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> <span class="type">long</span> begin, <span class="keyword">final</span> <span class="type">long</span> end, <span class="type">boolean</span> lock)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里使用hold这类的情况, 其实是为了做引用标记, 防止在插入/查新index数据过程中, 数据被清除了.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.mappedFile.hold()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">keyHash</span> <span class="operator">=</span> indexKeyHashMethod(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">slotPos</span> <span class="operator">=</span> keyHash % <span class="built_in">this</span>.hashSlotNum;</span><br><span class="line">        <span class="type">int</span> <span class="variable">absSlotPos</span> <span class="operator">=</span> IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line">        <span class="comment">// 比较疑惑的一个情况是, 在putKey中也看到了fileLock的存在, 但是都被注释了. 这个是为什么呢?</span></span><br><span class="line">        <span class="comment">// 并发写的话不是需要持有文件锁才能对文件数据更好操作吗???????</span></span><br><span class="line">        <span class="comment">// 盲猜！！！以前的设计是不处理hash冲突的. 只要有hash冲突了,</span></span><br><span class="line">        <span class="comment">//     那么就进行覆盖,所以这部分需要fileLock锁定某一行的绝对地址,之所以是绝对地址的起始部分.是因为更早期就固定了索引行的大小</span></span><br><span class="line">        <span class="comment">// 使用hash,冲突使用hash链表的时候 就更改了这一写法？？？？？？</span></span><br><span class="line">        <span class="type">FileLock</span> <span class="variable">fileLock</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos,</span></span><br><span class="line">                <span class="comment">// hashSlotSize, true);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">slotValue</span> <span class="operator">=</span> <span class="built_in">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">            <span class="comment">// if (fileLock != null) &#123;</span></span><br><span class="line">            <span class="comment">// fileLock.release();</span></span><br><span class="line">            <span class="comment">// fileLock = null;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="built_in">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                || <span class="built_in">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">nextIndexToRead</span> <span class="operator">=</span> slotValue; ; ) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (phyOffsets.size() &gt;= maxNum) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 解析捞数据的过程====&gt;按照index索引行协议来就行了</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">absIndexPos</span> <span class="operator">=</span></span><br><span class="line">                        IndexHeader.INDEX_HEADER_SIZE + <span class="built_in">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                            + nextIndexToRead * indexSize;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">keyHashRead</span> <span class="operator">=</span> <span class="built_in">this</span>.mappedByteBuffer.getInt(absIndexPos);</span><br><span class="line">                    <span class="type">long</span> <span class="variable">phyOffsetRead</span> <span class="operator">=</span> <span class="built_in">this</span>.mappedByteBuffer.getLong(absIndexPos + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">long</span> <span class="variable">timeDiff</span> <span class="operator">=</span> (<span class="type">long</span>) <span class="built_in">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">prevIndexRead</span> <span class="operator">=</span> <span class="built_in">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    timeDiff *= <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">long</span> <span class="variable">timeRead</span> <span class="operator">=</span> <span class="built_in">this</span>.indexHeader.getBeginTimestamp() + timeDiff;</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">timeMatched</span> <span class="operator">=</span> (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (keyHash == keyHashRead &amp;&amp; timeMatched) &#123;</span><br><span class="line">                        phyOffsets.add(phyOffsetRead);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (prevIndexRead &lt;= invalidIndex</span><br><span class="line">                        || prevIndexRead &gt; <span class="built_in">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                        || prevIndexRead == nextIndexToRead || timeRead &lt; begin) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    nextIndexToRead = prevIndexRead;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;selectPhyOffset exception &quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileLock != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fileLock.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Failed to release the lock&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.mappedFile.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;查询Index文件&quot;&gt;&lt;a href=&quot;#查询Index文件&quot; class=&quot;headerlink&quot; title=&quot;查询Index文件&quot;&gt;&lt;/a&gt;查询Index文件&lt;/h2&gt;</summary>
    
    
    
    <category term="中间件" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="http://jev001.github.io/tags/rocketmq/"/>
    
    <category term="源码精讲" scheme="http://jev001.github.io/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>rocket存储引擎[3]-构建index文件</title>
    <link href="http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocket%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E[3]-%E6%9E%84%E5%BB%BAindex%E6%96%87%E4%BB%B6/"/>
    <id>http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocket%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E[3]-%E6%9E%84%E5%BB%BAindex%E6%96%87%E4%BB%B6/</id>
    <published>2022-05-02T23:00:17.000Z</published>
    <updated>2023-02-08T07:14:52.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建Index文件"><a href="#构建Index文件" class="headerlink" title="构建Index文件"></a>构建Index文件</h2><span id="more"></span> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">20220427</span>]-commitlog文件初探三-构建Index索引文件。</span><br><span class="line">index文件的构建依靠了前面提到的rePut重放数据的功能.</span><br><span class="line"><span class="number">1.</span> 在写入index之前需要寻找到物理地址 对应的index文件. 如果此index文件没有则创建. 确保在此部分可以正常操作。</span><br><span class="line">   附加讨论. 在获取index文件的时代码中使用到了 读写锁 readWriteLock. 并且在读写锁中使用了共享变量</span><br><span class="line">   这部分有一个问题是, ReentrantReadWriteLock 的操作是cas控制的。内部没有使用到 内存屏障.readWrite底层的sync是没有没有<span class="keyword">volatile</span>标记.或者是已经synchronize包含的.那么怎么防止指令重拍呢？ 其实方式很简单, 在方法内. 将共享变量使用 `&#123;&#125;`包起来,产生一个新的作用域. 变量的初始化在`&#123;&#125;`作用域之前. 这样就杜绝了 指令重拍优化了. 这个方式也是对变量的 mutable immutable的解释====&gt; 在c++领域中 mutable是指 关键词 和const同为修饰作用的.</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 通过index文件格式的解析.</span><br><span class="line">    <span class="comment">// 通过该index文件的结构. 可以了解到,索引文件本质上是一个hashmap.的文件存储实现模式。</span></span><br><span class="line">    <span class="comment">//    从索引槽到行内容,索引槽 对应的是 hashmap的 table索引槽,</span></span><br><span class="line">    <span class="comment">//    索引行中存储了pre_content_index的指针, 用于解决hash冲突,</span></span><br><span class="line">    <span class="comment">//    table索引槽中存储 最后一个hash的 content_index指针.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 对索引文件中的key进行设置. phyOffset为 commitLog中的地址信息. storeTime为commitLog 入库时间</span></span><br><span class="line">    <span class="comment">// 此处的重点为. 后续通过key进行计算过滤怎么处理。</span></span><br><span class="line">    <span class="comment">// 换句话说. 索引的数据结构是怎么样的。</span></span><br><span class="line">    <span class="comment">// 从 下方计算可以推测出. rocketmq 对于index文件的规则可以参考下方</span></span><br><span class="line">    <span class="comment">// |--------------header---index_header(40字节)------------------|</span></span><br><span class="line">    <span class="comment">// |--------------header---hash_slot----------------------------|</span></span><br><span class="line">    <span class="comment">// |--------------content_0-------------------------------------|</span></span><br><span class="line">    <span class="comment">// |--------------content_1-------------------------------------|</span></span><br><span class="line">    <span class="comment">// |--------------content_2-------------------------------------|</span></span><br><span class="line">    <span class="comment">// |--------------content_3-------------------------------------|</span></span><br><span class="line">    <span class="comment">// 其中头部 部分可以分为两种.</span></span><br><span class="line">    <span class="comment">//    第一种为 索引文件描述,内容固定,和索引内容基本无关. 总大小为40字节</span></span><br><span class="line">    <span class="comment">//    第二种为 索引槽 数据总大小为 单个槽大小*最大槽总数. 其中单个槽大小固定为4字节,槽总数通过messageStoreConfig 传入。</span></span><br><span class="line">    <span class="comment">//      索引槽 内容为查询key的 hash值. 所以单个槽内容为4字节.</span></span><br><span class="line">    <span class="comment">//      既然 索引槽内容为hash值, 那么可以大胆的推断出 index文件使用 hash计算得到该key的相对于槽而言的位置大小,通过槽内的内容也就可以知道.该key所对应数据的真实文件位置,解释按照下方给出</span></span><br><span class="line">    <span class="comment">// 其中除却头部部分,其他均为索引内容(索引行内容方案 ☆☆☆☆☆)</span></span><br><span class="line">    <span class="comment">//    平时通过内存中的hash,list结构很容易找出值在哪里.如果需要放在文件系统中呢？并且如果内容长度是可变的话,怎么找寻呢？</span></span><br><span class="line">    <span class="comment">//    如果需要考虑可变内容,那么还需要在额外存放行内容大小,如果是按照list顺序遍历的方式,这样是没问题的. 但是这样就导致每次查询都从0还是,查询效率就非常的慢了,</span></span><br><span class="line">    <span class="comment">//       当然也可以做二分查找,但是总共需要跳过的字节数还是需要计算出来</span></span><br><span class="line">    <span class="comment">////       |content0_index|content0_size|content0_data|  40 字节 0~40</span></span><br><span class="line">    <span class="comment">///        |content1_index|content1_size|content1_data|  60 字节 40~100</span></span><br><span class="line">    <span class="comment">///        |content2_index|content2_size|content2_data|  80 字节 100~180</span></span><br><span class="line">    <span class="comment">///        查找一个数据需要通过 0开始遍历对size进行累加才能计算出 需要跳过的数据  比如需要查找content_2的数据,需要对content_0和content_1的数据进行累加 =100,这个数据为跳过数据</span></span><br><span class="line">    <span class="comment">//    那么就可以考虑规避这个问题,使用固定长度的`内容行` 此时就有计算规则了. 文件行的内容起始位置=文件头部(包含索引槽和索引文件描述)+偏移地址*内容长度</span></span><br><span class="line">    <span class="comment">//         |content0_index|content0_data|  40 字节 0~40</span></span><br><span class="line">    <span class="comment">//         |content1_index|content1_data|  40 字节 40~80</span></span><br><span class="line">    <span class="comment">//         |content2_index|content2_data|  40 字节 80~120</span></span><br><span class="line">    <span class="comment">//         |content3_index|content3_data|  40 字节 120~160</span></span><br><span class="line">    <span class="comment">//       通过固定长度的内容行. 可以很便捷计算出需要跳过的数据  同样按照查找 content_2为例. 需要跳过的数据 2 * 40 = 80 并不需要针对每个进行累加</span></span><br><span class="line">    <span class="comment">// 上述方案概要完成, 可以细则解释</span></span><br><span class="line">    <span class="comment">// Q1 文件头部存放了什么?</span></span><br><span class="line">    <span class="comment">// A1 index_header 主要存放是的整体索引文件 元数据信息。</span></span><br><span class="line">    <span class="comment">//   其中包含</span></span><br><span class="line">    <span class="comment">//   1. beginTimestampIndex 第一个写入消息时创建索引文件创建时间戳. 使用的是 long 占用 8字节</span></span><br><span class="line">    <span class="comment">//   2. endTimestampIndex 索引文件最后写入的时间戳, 使用的是 long 占用8字节</span></span><br><span class="line">    <span class="comment">//   3. beginPhyoffsetIndex 第一个写入消息的物理地址  使用的是 long 占用8字节</span></span><br><span class="line">    <span class="comment">//   4. endPhyoffsetIndex 最后一个写入消息的物理地址  使用的是 long 占用8字节</span></span><br><span class="line">    <span class="comment">//   5. hashSlotcountIndex 索引槽的总数 已经使用的索引槽. 配置文件内有固定的索引槽. 但是对于文件内真实存在的就需要文件自己记录,用于后续使用 使用的是int 占用4字节</span></span><br><span class="line">    <span class="comment">//   6. indexCountIndex 索引内容的总数 已经使用的索引内容. 该数据一般和`hashSlotcountIndex` 是一样的。   使用的是int 占用4字节</span></span><br><span class="line">    <span class="comment">// Q2 索引槽中到底存放了什么?</span></span><br><span class="line">    <span class="comment">// A2 索引槽存放是的 内容行的编号. 每次新增一个index的时候 index_header中的index_count就需要增加一个.然后存放在对应的文件槽内。</span></span><br><span class="line">    <span class="comment">// Q3 content 固定长度后包含哪些东西?一个索引文件中包含哪些数据</span></span><br><span class="line">    <span class="comment">// A3 content 内容包含.</span></span><br><span class="line">    <span class="comment">// 1. ketHash.该内容行所使用的hash值. ====&gt;类似于使用了分表也要记录根据什么条件进行的分表</span></span><br><span class="line">    <span class="comment">// 2. phyOffset 内容行commitLog 物理地址 ====&gt;为了寻找到具体的消息</span></span><br><span class="line">    <span class="comment">// 3. timeDiff 内容行commitLog 落库时间相对于索引文件的间隔时间====&gt; 用于过期？间隔时间短的表示最初进入的. 当出现hash冲突的时候提供一个去处逻辑？</span></span><br><span class="line">    <span class="comment">// 4. slotValue 存储的上一次hash计算出的 文件行具体地址。 ☆☆☆☆☆ 重要.</span></span><br><span class="line">    <span class="comment">// Q4 从上描述得到的信息可以该方案有一个严重的弊端(仅仅使用content_index去定位数据). 当出现hash冲突后怎么去解决？？？</span></span><br><span class="line">    <span class="comment">// A4 在hash冲突的行内. 记录上一次文件行的content_index,这样在一个hash槽内就组成了一个链表结构。并且这部分是属于头插法====&gt;</span></span><br><span class="line">    <span class="comment">//       将最新的记录插入到hash槽内, 再辅佐于keyHash真实的值. 就可以定位到数据了</span></span><br><span class="line">    <span class="comment">//  举例. 现在有四个key. 这四个key对应的&#123;k0,k1,k2,k3&#125; hash都落入到了一个hash_slot[1]中</span></span><br><span class="line">    <span class="comment">//  那么hash_slot[1] 的变化在进行四次插入后有如下变化：</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//  hash_slot[1]=content0_index =&gt; hash_slot[1]=content1_index =&gt; hash_slot[1]=content2_index =&gt; hash_slot[1]=content2_index</span></span><br><span class="line">    <span class="comment">//         |-------------[hash_slot[1]]--------------------------------------|</span></span><br><span class="line">    <span class="comment">//         | 索引行,行标index_count|内容   |hash值|上一个索引行,航标   |</span></span><br><span class="line">    <span class="comment">//         |content0_index|content0_data|keyHash_0|-1            |</span></span><br><span class="line">    <span class="comment">//         |content1_index|content1_data|keyHash_1|content0_index|</span></span><br><span class="line">    <span class="comment">//         |content2_index|content2_data|keyHash_2|content1_index|</span></span><br><span class="line">    <span class="comment">//         |content3_index|content3_data|keyHash_3|content2_index|</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 逻辑上 索引文件的 索引槽头部和索引内容是一个 hashmap. 采用的是头插法</span></span><br><span class="line">    <span class="comment">//</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> phyOffset, <span class="keyword">final</span> <span class="type">long</span> storeTimestamp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.indexHeader.getIndexCount() &lt; <span class="built_in">this</span>.indexNum) &#123;</span><br><span class="line">            <span class="comment">// 计算这个key的字符串hash</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">keyHash</span> <span class="operator">=</span> indexKeyHashMethod(key);</span><br><span class="line">            <span class="comment">// 计算出hash所在的桶是多少</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">slotPos</span> <span class="operator">=</span> keyHash % <span class="built_in">this</span>.hashSlotNum;</span><br><span class="line">            <span class="comment">//   抽象的概念的 桶坐标？.绝对地址？？？不是很明白这个.====&gt;hashSlotNum 这个是配置的. 通过indexService传入,indexService中的由MessageStoreConfig传入。</span></span><br><span class="line">            <span class="comment">// 通过简单计算理解 absSlotPos表示的是 在Index这个文件中. 的物理地址。其中slotPos是逻辑地址,表示的是桶的序号.然后因为每个slot是固定长度的.</span></span><br><span class="line">            <span class="comment">//   那么就可以通过slotPos*slotSize的方式得到这个数据的绝对地址 再然后因为每个index文件有头部信息, 这个需要跳过的,</span></span><br><span class="line">            <span class="comment">// 一般这么操作,是因为数据最终是需要落地在文件中的. 采用一行一个数据的方式是可以的,但是这样的数据是非紧凑型的.</span></span><br><span class="line">            <span class="comment">//   那么就引发了一个问题. 为什么index需要使用这样的方式进行 读写？对于index这样高频读写的数据, 不太适合</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">absSlotPos</span> <span class="operator">=</span> IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">            <span class="type">FileLock</span> <span class="variable">fileLock</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从被注释掉的痕迹看.  原本是打算 文件锁的.☆☆☆☆ 文件锁是系统编程基础,需要着重看</span></span><br><span class="line">                <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos, hashSlotSize,</span></span><br><span class="line">                <span class="comment">// false);</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">slotValue</span> <span class="operator">=</span> <span class="built_in">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">                <span class="comment">// 存在hash冲突如何处理</span></span><br><span class="line">                <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="built_in">this</span>.indexHeader.getIndexCount()) &#123;</span><br><span class="line">                    slotValue = invalidIndex;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">long</span> <span class="variable">timeDiff</span> <span class="operator">=</span> storeTimestamp - <span class="built_in">this</span>.indexHeader.getBeginTimestamp();</span><br><span class="line"></span><br><span class="line">                timeDiff = timeDiff / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.indexHeader.getBeginTimestamp() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    timeDiff = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                    timeDiff = Integer.MAX_VALUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    timeDiff = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">absIndexPos</span> <span class="operator">=</span></span><br><span class="line">                    IndexHeader.INDEX_HEADER_SIZE + <span class="built_in">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                        + <span class="built_in">this</span>.indexHeader.getIndexCount() * indexSize;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line">                <span class="built_in">this</span>.mappedByteBuffer.putLong(absIndexPos + <span class="number">4</span>, phyOffset);</span><br><span class="line">                <span class="built_in">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>, (<span class="type">int</span>) timeDiff);</span><br><span class="line">                <span class="built_in">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>, slotValue);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.mappedByteBuffer.putInt(absSlotPos, <span class="built_in">this</span>.indexHeader.getIndexCount());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.indexHeader.setBeginPhyOffset(phyOffset);</span><br><span class="line">                    <span class="built_in">this</span>.indexHeader.setBeginTimestamp(storeTimestamp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (invalidIndex == slotValue) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.indexHeader.incHashSlotCount();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">this</span>.indexHeader.incIndexCount();</span><br><span class="line">                <span class="built_in">this</span>.indexHeader.setEndPhyOffset(phyOffset);</span><br><span class="line">                <span class="built_in">this</span>.indexHeader.setEndTimestamp(storeTimestamp);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;putKey exception, Key: &quot;</span> + key + <span class="string">&quot; KeyHashCode: &quot;</span> + key.hashCode(), e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileLock != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        fileLock.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;Failed to release the lock&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Over index file capacity: index count = &quot;</span> + <span class="built_in">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                + <span class="string">&quot;; index max num = &quot;</span> + <span class="built_in">this</span>.indexNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;构建Index文件&quot;&gt;&lt;a href=&quot;#构建Index文件&quot; class=&quot;headerlink&quot; title=&quot;构建Index文件&quot;&gt;&lt;/a&gt;构建Index文件&lt;/h2&gt;</summary>
    
    
    
    <category term="中间件" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="http://jev001.github.io/tags/rocketmq/"/>
    
    <category term="源码精讲" scheme="http://jev001.github.io/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>rocket存储引擎[2]-构建consumerQueue文件</title>
    <link href="http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocket%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E[2]-%E6%9E%84%E5%BB%BAconsumerQueue%E6%96%87%E4%BB%B6/"/>
    <id>http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocket%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E[2]-%E6%9E%84%E5%BB%BAconsumerQueue%E6%96%87%E4%BB%B6/</id>
    <published>2022-05-02T23:00:16.000Z</published>
    <updated>2023-02-08T07:14:52.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建ConsumerQueue"><a href="#构建ConsumerQueue" class="headerlink" title="构建ConsumerQueue"></a>构建ConsumerQueue</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对consumeQueue进行增强处理. 除却consumerQueue基础 用于查找 topic 对应的消息 tag.</p><ul><li>额外维护了一份增强的数据 用于存储 tag信息,消息入库时间,bitmap过滤信息. 这些都是额外的</li></ul><span id="more"></span> <h3 id="构建主流程"><a href="#构建主流程" class="headerlink" title="构建主流程"></a>构建主流程</h3><p>上述了解了消息重放,而构建consumerQueue正是通过消息重放实现的.</p><p>了解到consumerQueue的构建流程. 主要是consumerQueueTable.在构建过程中会通过 findConsumerQueue,如果不存在 该topic的索引,则新创建一个.</p><p>consumerQueue中存储的是 topic下对应消息的地址,也就是这个数据使得 基于消息订阅成为了可能</p><p>另外,rocketmq对原始的consumerQueue进行了增强,额外存储了 入库时间,bitmap等信息.这些信息存储在 consumerQueue中 在写入consumerQueue对应的mapped中会额外写入这个信息</p><ul><li>org.apache.rocketmq.store.DefaultMessageStore.CommitLogDispatcherBuildConsumeQueue</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title class_">CommitLogDispatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(DispatchRequest request)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">tranType</span> <span class="operator">=</span> MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">            <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">                <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">                <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                    <span class="comment">// 构建consumerQueue,consumerQueue是按照topic为k,存储在consumeQueueTable中的.</span></span><br><span class="line">                    <span class="comment">// consumerQueue中存储的数据包含, 消息offset,消息大小,以及tagCode,目前tagCode为消息的hash?md5比较合适吧。</span></span><br><span class="line">                    <span class="comment">// 至于为什么是tagCode,而不是直接称呼为tagMd5,可能是因为在早期,tag数据是可以按照 1,2,3这样的需要,或者是 uuid这样的存储的.</span></span><br><span class="line">                    <span class="comment">// 但是为了读写方便?不逊要考虑读取的长度问题,统一使用一个定长字符串表示了, 这个定长字符串也就是之前说的 md5.</span></span><br><span class="line">                    DefaultMessageStore.<span class="built_in">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">                <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;构建ConsumerQueue&quot;&gt;&lt;a href=&quot;#构建ConsumerQueue&quot; class=&quot;headerlink&quot; title=&quot;构建ConsumerQueue&quot;&gt;&lt;/a&gt;构建ConsumerQueue&lt;/h2&gt;&lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;p&gt;对consumeQueue进行增强处理. 除却consumerQueue基础 用于查找 topic 对应的消息 tag.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;额外维护了一份增强的数据 用于存储 tag信息,消息入库时间,bitmap过滤信息. 这些都是额外的&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="中间件" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="http://jev001.github.io/tags/rocketmq/"/>
    
    <category term="源码精讲" scheme="http://jev001.github.io/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>rocket存储引擎[1]-消息重放</title>
    <link href="http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocket%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E[1]-%E6%B6%88%E6%81%AF%E9%87%8D%E6%94%BE/"/>
    <id>http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocket%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E[1]-%E6%B6%88%E6%81%AF%E9%87%8D%E6%94%BE/</id>
    <published>2022-05-02T23:00:15.000Z</published>
    <updated>2023-02-08T07:14:52.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息重放"><a href="#消息重放" class="headerlink" title="消息重放"></a>消息重放</h2><ul><li>rocketmq在完成将数据落入commitLog后,后台会存在<code>一个</code>线程将刚刚提交的数据,<code>重放</code>处理,使得完成一些<code>同步/复制</code>动作,这些动作包括但不限于<code>构建标签索引index文件</code>,<code>构建用于topic订阅的consumerQueue文件</code>等</li></ul><span id="more"></span> <h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>了解了 重放消息(复制消息) 再处理的过程, 当用户putMessage后消息进入 commitLog之后的事情。<br>利用 reput游标 对commitLog中的数据 读取.</p><ol><li>其中列出重放算法. 是单指针移动法, 重放指针步进. commitLog中的max边界指针在put时变动.</li><li>其中这个重放动作 是在额外的线程中处理的. 该处理线程为 <code>ReputMessageService</code>. 内部服务由一个死循环(由stop变量控制),做的,内部睡眠1毫秒。<br>&#x3D;&#x3D;&#x3D;&#x3D;&gt; 其实就是可以看做, 一个1毫秒的定时器,只不过这个定时器是穿行的. 上一个没有执行完不能执行下一个.</li><li>其中.默认的重放动作支持 可以查看 <code>CommitLogDispatcher</code> 找到实现类.<br>   在存储系统中支持的为<br>   (1) 用于构建consumerQueue的<code>CommitLogDispatcherBuildConsumeQueue</code><br>       &#x3D;&#x3D;&#x3D;&gt;废弃,ConsumerQueue的创建不再是放在<code>CommitLogDispatcherBuildConsumeQueue</code>中维护了 而是放在<code>store中的 findConsumerQueue</code>中维护,如果没有则创建一个新的逻辑性queue,猜测原因是 每条数据进行consumerQueue维护,使得consumerQueue的读写量较大？？？这个原因暂定</li></ol><p>   (2) 用于构建index的<code>CommitLogDispatcherBuildIndex</code><br>   在broker中额外支持的为<br>   (3) 在上层broker中实现了一个 <code>CommitLogDispatcherCalcBitMap</code>,作为扩展.该 dispatch是用于对构建消息的布隆过滤器的.</p><h2 id="重放数据思路"><a href="#重放数据思路" class="headerlink" title="重放数据思路"></a>重放数据思路</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1.</span>  当前重放游标 reputFromOffset</span><br><span class="line">  <span class="number">2.</span>  当前commitLog 数据其实游标 commitLog.minOffset(startOffset)</span><br><span class="line">  <span class="number">3.</span>  当前commitLog 数据 commitLog.maxOffset(endOffset)</span><br><span class="line">   reput  min        max</span><br><span class="line">    ↓     ↓           ↓</span><br><span class="line">    <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>   mappedFileQueue</span><br><span class="line"> 当发现 reput小于min时表示, 表示当前这个定时器已经经过很久才重新启动,需要修补reput指向min时,才能确保逻辑偏移量正确. 重放数据可能不再是针对该commitLog了？？？ 这个其实存疑, 因为commitLog 中的游标是一致往前递进的</span><br><span class="line"> 在按照reput获取到对应游标后, reput游标递进往前增, 前进步伐按照数据size决定</span><br><span class="line"><span class="comment">// 这里面就需要插一句了. commitLog内的数据不是按照固定长度进行的. 下一条消息的起始地址由 currentOffset+currentSize决定. 所以reput的下一个数据地址也同样由size决定</span></span><br><span class="line"> 在执行了一个mappedFile完成之后之后, 游标将移到下一个mappedFile中.</span><br><span class="line"> 上述画图中的<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> 对中间的commitLog消息展示可能不太直观,将数据放大后查看</span><br><span class="line"></span><br><span class="line">  mapped_1   |  mapped_2       |  mapped_3 |</span><br><span class="line">                        reputOffset</span><br><span class="line">             |               ↓ |           |</span><br><span class="line">          <span class="number">0</span> <span class="number">1</span>| <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> |<span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span>| <span class="number">14</span></span><br><span class="line">             |                 |           |</span><br><span class="line"></span><br><span class="line">   在这个场景下. reputOffset 的是 mapped_2中的消息数据,其中因为<span class="number">9</span>号数据是不正确的. totalSize不正确, 为了保持流程完整, 将跳过这个消息.</span><br><span class="line">   跳过的消息不在以 dispatchRequest中描述的size. 因为这个结果已经不正确了. 还是按照这个size进行偏移, 那么会影响到`<span class="number">10</span>`号数据的读取,那么就需要在内部进行偏移处理.得到下一个有效的偏移量了</span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul><li>org.apache.rocketmq.store.DefaultMessageStore.ReputMessageService#doReput</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReput</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/// 当前重新放入的游标 较小. 这个是因为当前commitLog 提交的数据过期了？？？？没太理解这个</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.reputFromOffset &lt; DefaultMessageStore.<span class="built_in">this</span>.commitLog.getMinOffset()) &#123;</span><br><span class="line">        log.warn(<span class="string">&quot;The reputFromOffset=&#123;&#125; is smaller than minPyOffset=&#123;&#125;, this usually indicate that the dispatch behind too much and the commitlog has expired.&quot;</span>,</span><br><span class="line">            <span class="built_in">this</span>.reputFromOffset, DefaultMessageStore.<span class="built_in">this</span>.commitLog.getMinOffset());</span><br><span class="line">        <span class="built_in">this</span>.reputFromOffset = DefaultMessageStore.<span class="built_in">this</span>.commitLog.getMinOffset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只要commitlog 还有数据和重放没有处理完就需要进行处理. 经最大可能(重放游标 小于commitLog中的最大游标)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">boolean</span> <span class="variable">doNext</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="built_in">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().isDuplicationEnable()</span><br><span class="line">            &amp;&amp; <span class="built_in">this</span>.reputFromOffset &gt;= DefaultMessageStore.<span class="built_in">this</span>.getConfirmOffset()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取offset对应的mapped文件 从mappedQueue中.</span></span><br><span class="line">        <span class="type">SelectMappedBufferResult</span> <span class="variable">result</span> <span class="operator">=</span> DefaultMessageStore.<span class="built_in">this</span>.commitLog.getData(reputFromOffset);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这个操作在第一次执行的时候意义比较大. 这个的说法是 最重复的游标进行起始步骤的变更.</span></span><br><span class="line">                <span class="comment">// 这样就算后续 reputFrom执行到之间因为 增加size的方式被修改了. 然后出现了问题.也能将整个commitLog重新提交.类似事物</span></span><br><span class="line">                <span class="built_in">this</span>.reputFromOffset = result.getStartOffset();</span><br><span class="line">                <span class="comment">// 读取mapped文, 至于怎么读, 以及从哪里读 需要 获得的result中的 byteBuffer确定了.</span></span><br><span class="line">                <span class="comment">// 在使用byteBuffer时. 会按照mapped中对于 commitLog的格式读取. 封装好 DispatchRequest. 这个request内. 含有这一条消息commit的size大小</span></span><br><span class="line">                <span class="comment">//   在 commitLog中 这个大小就是totalSize</span></span><br><span class="line">                <span class="comment">//   在读取commit的过程中. 可能会因为 commitLog中的数据自身是不完善的, 是错误格式的(错误包含 crc校验不通过,或者这条消息标记为空白等), 此时重放流程reput还是需要继续进行下去. 那么只能是说. 主动跳过这个数据</span></span><br><span class="line">                <span class="comment">//// 补充说明, 因为readSize和totalSize对不上的情况. 也就是不处理该消息了. 但是流程还是需要继续, 那么size还是需要跳过这个数据,那么就可能出现在 当前mapped处理完成后, 重新从mappedQueue中拿到的 offset大于reputFromOffset这个</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">readSize</span> <span class="operator">=</span> <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">                    <span class="comment">// 将生产者提交的消息 .重新规整一下封装成 dispatch使用的 消息</span></span><br><span class="line">                    <span class="type">DispatchRequest</span> <span class="variable">dispatchRequest</span> <span class="operator">=</span></span><br><span class="line">                        DefaultMessageStore.<span class="built_in">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dispatchRequest.getBufferSize() == -<span class="number">1</span> ? dispatchRequest.getMsgSize() : dispatchRequest.getBufferSize();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 将已经存储在commitLog中的消息重发出去.</span></span><br><span class="line">                            DefaultMessageStore.<span class="built_in">this</span>.doDispatch(dispatchRequest);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 这个是针对 主从模式附加的功能, 非重放主逻辑,等待看到主从的时候再回头看这个 TODO Jonah ON 2022-04-26 created</span></span><br><span class="line">                            <span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">                                    &amp;&amp; DefaultMessageStore.<span class="built_in">this</span>.brokerConfig.isLongPollingEnable()</span><br><span class="line">                                    &amp;&amp; DefaultMessageStore.<span class="built_in">this</span>.messageArrivingListener != <span class="literal">null</span>) &#123;</span><br><span class="line">                                DefaultMessageStore.<span class="built_in">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">                                    dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">                                    dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">                                    dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">                                notifyMessageArrive4MultiQueue(dispatchRequest);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="built_in">this</span>.reputFromOffset += size;</span><br><span class="line">                            readSize += size;</span><br><span class="line">                            <span class="comment">// 这个是针对 主从模式附加的功能, 非重放主逻辑,等待看到主从的时候再回头看这个 TODO Jonah ON 2022-04-26 created</span></span><br><span class="line">                            <span class="keyword">if</span> (DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().getBrokerRole() == BrokerRole.SLAVE) &#123;</span><br><span class="line">                                DefaultMessageStore.<span class="built_in">this</span>.storeStatsService</span><br><span class="line">                                    .getSinglePutMessageTopicTimesTotal(dispatchRequest.getTopic()).add(<span class="number">1</span>);</span><br><span class="line">                                DefaultMessageStore.<span class="built_in">this</span>.storeStatsService</span><br><span class="line">                                    .getSinglePutMessageTopicSizeTotal(dispatchRequest.getTopic())</span><br><span class="line">                                    .add(dispatchRequest.getMsgSize());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="built_in">this</span>.reputFromOffset = DefaultMessageStore.<span class="built_in">this</span>.commitLog.rollNextFile(<span class="built_in">this</span>.reputFromOffset);</span><br><span class="line">                            readSize = result.getSize();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;[BUG]read total count not equals msg total size. reputFromOffset=&#123;&#125;&quot;</span>, reputFromOffset);</span><br><span class="line">                            <span class="built_in">this</span>.reputFromOffset += size;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            doNext = <span class="literal">false</span>;</span><br><span class="line">                            <span class="comment">// If user open the dledger pattern or the broker is master node,</span></span><br><span class="line">                            <span class="comment">// it will not ignore the exception and fix the reputFromOffset variable</span></span><br><span class="line">                            <span class="keyword">if</span> (DefaultMessageStore.<span class="built_in">this</span>.getMessageStoreConfig().isEnableDLegerCommitLog() ||</span><br><span class="line">                                DefaultMessageStore.<span class="built_in">this</span>.brokerConfig.getBrokerId() == MixAll.MASTER_ID) &#123;</span><br><span class="line">                                log.error(<span class="string">&quot;[BUG]dispatch message to consume queue error, COMMITLOG OFFSET: &#123;&#125;&quot;</span>,</span><br><span class="line">                                    <span class="built_in">this</span>.reputFromOffset);</span><br><span class="line">                                <span class="built_in">this</span>.reputFromOffset += result.getSize() - readSize;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                result.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doNext = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;消息重放&quot;&gt;&lt;a href=&quot;#消息重放&quot; class=&quot;headerlink&quot; title=&quot;消息重放&quot;&gt;&lt;/a&gt;消息重放&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;rocketmq在完成将数据落入commitLog后,后台会存在&lt;code&gt;一个&lt;/code&gt;线程将刚刚提交的数据,&lt;code&gt;重放&lt;/code&gt;处理,使得完成一些&lt;code&gt;同步/复制&lt;/code&gt;动作,这些动作包括但不限于&lt;code&gt;构建标签索引index文件&lt;/code&gt;,&lt;code&gt;构建用于topic订阅的consumerQueue文件&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="中间件" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="http://jev001.github.io/tags/rocketmq/"/>
    
    <category term="源码精讲" scheme="http://jev001.github.io/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>rocket存储引擎[0]-消息总结</title>
    <link href="http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocketmq/"/>
    <id>http://jev001.github.io/2022/05/02/%E4%B8%93%E9%A2%98/rockemq%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/rocketmq/</id>
    <published>2022-05-02T23:00:14.000Z</published>
    <updated>2023-02-08T07:14:52.272Z</updated>
    
    <content type="html"><![CDATA[<p>rocketmq 和 kafka 选择区别？为什么推荐使用rocketmq</p><p>主要原因是对于 集群模式下的问题.<br>rocketmq 中是按照 主写, 从读的模式. 只要主挂了. 在选举的前, 只能读.<br>  rocketmq内部最初就是使用主从模式, 没有说是要做 leader切换的。在4.5之后启用了Dleader的方式进行commitLog的写入.该方式的写入是依靠raft模式进行的,<br>  在进行raft</p><p>kafka是存储于zookeeper中的.<br>  kafka使用zookeeper存储topicTable等信息   </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;rocketmq 和 kafka 选择区别？为什么推荐使用rocketmq&lt;/p&gt;
&lt;p&gt;主要原因是对于 集群模式下的问题.&lt;br&gt;rocketmq 中是按照 主写, 从读的模式. 只要主挂了. 在选举的前, 只能读.&lt;br&gt;  rocketmq内部最初就是使用主从模式, </summary>
      
    
    
    
    <category term="中间件" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://jev001.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="http://jev001.github.io/tags/rocketmq/"/>
    
    <category term="源码精讲" scheme="http://jev001.github.io/tags/%E6%BA%90%E7%A0%81%E7%B2%BE%E8%AE%B2/"/>
    
    <category term="总结" scheme="http://jev001.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
